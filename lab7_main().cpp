#include "Vector.h"
#include <iostream>
#include "Time.h"
using namespace std;
void main()
{
	 
 
	Time t;
	cin >> t;
	cout << t;
	Vector<Time>A(5, t);
	cin >> A;
	cout << A << endl;
	Vector <Time>B(10, t);
	cout << B << endl;
	B = A;
	cout << B << endl;
	cout << A[2] << endl;
	cout << "size=" << A() << endl;
	B = A + t;
	cout << B << endl;
	B = B + 532;
	cout << B << endl;

}
//1. В чем смысл использования шаблонов ?
//  С помощью шаблона можно отделить алгоритмы от конкретных типов
//  данных, передавая тип в качестве параметра, или создавать параметризированные 
//  классы для создании
//2. Каковы синтаксис / семантика шаблонов функций ?
//  Формат шаблона:
//  template <параметры_шаблона>
//  заголовок_функции
//  { тело функции }
//3. Каковы синтаксис / семантика шаблонов классов ?
//  Формат шаблона:
//  template <параметры шаблона>
//  class имя_класса
//  { … };
//4. Что такое параметры шаблона функции ?
//  Параметр, благодаря которому можно вызвать функцию от перемеренной с любым типом.
//5. Перечислите основные свойства параметров шаблона функции.
//	1. Имена параметров шаблона должны быть уникальными во всем определении шаблона.
//	2. Список параметров шаблона функции не может быть пустым, так как при этом теряется возможность параметризации и шаблон функций становится обычным определением конкретной функции.
//	3. В списке параметров шаблона функций может быть несколько параметров.Каждый из них должен начинаться со служебного слова class.Например, допустим такой заголовок шаблона :
//	template <class type1, class type2>
//	Соответственно, неверен заголовок :
//	template < class type1, type2, type3>
//	4. Недопустимо использовать в заголовке шаблона параметры с одинаковыми именами.
//6. Как записывать параметр шаблона ?
// template<class Имя класса>
//7. Можно ли перегружать параметризованные функции ?
// Да, можно, достаточно поменять тип данных у параметров функции.
//8. Перечислите основные свойства параметризованных классов.
//	1. Компонентные функции параметризованного класса автоматически являются параметризованными.
//	2. Дружественные функции, которые описываются в параметризованном классе, не являются автоматически параметризованными функциями
//	3.С одной стороны, шаблоны могут быть производными (наследоваться) как от шаблонов, так и от обычных классов, 
//	с другой стороны, они могут использоваться в качестве базовых для других шаблонов или классов.
//	4. Статические переменные шаблонов классов необходимо инициализировать для каждого используемого типа данных.
//9. Все ли компонентные функции параметризованного класса являются параметризованными ?
//	Нет, шаблоны классов могут содержать статические элементы, дружественные функции и классы.
//10. Являются ли дружественные функции, описанные в параметризованном
//классе, параметризованными ?
// Не всегда, зависит от функции и её логики
//11. Могут ли шаблоны классов содержать виртуальные компонентные функции ?
// Нет не могут.
//12. Как определяются компонентные функции параметризованных классов вне
//определения шаблона класса ?
// Все определение шаблонного класса размещается в заголовочном файле. 
//13. Что такое инстанцирование шаблона ?
// Процесс генерации компилятором определения конкретного класса по шаблону класса и 
// аргументам шаблона.
//14. На каком этапе происходит генерирование определения класса по шаблону ?
// На момент объявления объекта либо объявления указателя.
// 
// 
// 
// 
// 
//